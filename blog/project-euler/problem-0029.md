---
layout: "project-euler-post"
problem_number: 29
problem_name: "Distinct Powers"
date: 2025-12-21
difficulty: 5
benchmark_file: "problem-0029"
benchmark_key: "count_distinct_powers_100"
---

> Consider all integer combinations of $a^b$ for $2 \le a \le 5$ and $2 \le b \le 5$:
>
> ```math
> \begin{array}{rrrr}
>   2^2=4, &2^3=8, &2^4=16, &2^5=32\\
>   3^2=9, &3^3=27, &3^4=81, &3^5=243\\
>   4^2=16, &4^3=64, &4^4=256, &4^5=1024\\
>   5^2=25, &5^3=125, &5^4=625, &5^5=3125
> \end{array}
> ```
>
> If they are then placed in numerical order, with any repeats removed, we get the following sequence of $15$ distinct terms:
>
> $$4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.$$
>
> How many distinct terms are in the sequence generated by $a^b$ for $2 \le a \le 100$ and $2 \le b \le 100$?

Computing $a^b$ directly requires arbitrary precision integers, and this is definitely fine for the original problem. But going to numbers like $1000^{1000}$ and larger we'll want something more efficient.

I tried using logarithms (since $a^b = c^d \Leftrightarrow b \log a = d \log c$) but floating-point precision is an issue and I could not find a good similarity threshold to classify two floats as corresponding to the same value of $a^b$, although a threshold of $10^{-10}$ worked for the original problem.

Instead we track exponents rather than computing powers. The idea is that $4^3 = 2^6$ and $8^2 = 2^6$ are duplicates because they're both $2^6$. More generally, if $a = r^k$ for some primitive root $r$ (a number that isn't itself a perfect power), then $a^b = r^{kb}$.

So we group bases by their primitive root. For $n = 100$, the bases $\{2, 4, 8, 16, 32, 64\}$ all reduce to powers of 2. When raised to exponents $b \in [2, 100]$, they produce $2^{kb}$ for $k \in \{1, 2, 3, 4, 5, 6\}$. The number of distinct powers from this group is just the number of unique products $kb$. This count only depends on how many powers of the root fit in $[2, n]$. For $n = 100$, there are 6 powers of 2, 4 powers of 3, and most numbers have only 1 (themselves). We precompute the unique exponent count for each case:

```julia
function count_distinct_powers(n)
    max_log = floor(Int, log2(n))

    unique_counts = Vector{Int}(undef, max_log)
    for max_power in 1:max_log
        seen = Set{Int}()
        for k in 1:max_power
            for j in 2:n
                push!(seen, k * j)
            end
        end
        unique_counts[max_power] = length(seen)
    end

    is_perfect_power = falses(n)
    result = 0

    for base in 2:n
        if is_perfect_power[base]
            continue
        end

        power_count = 1
        val = base
        while true
            next_val = val * base
            if next_val > n
                break
            end
            val = next_val
            power_count += 1
            is_perfect_power[val] = true
        end

        result += unique_counts[power_count]
    end

    return result
end
```

This approach uses only integer arithmetic with no floating-point precision issues. The precomputation loops over $m$ from 1 to $\log_2 n$, and for each $m$ iterates over $k \in [1, m]$ and $b \in [2, n]$, giving $n \cdot (1 + 2 + \cdots + \log_2 n) = O(n \log^2 n)$ set insertions. The main loop is $O(n)$.

| $n$     | Distinct powers | Time |
|---------|-----------------|------|
| $10^2$  | 9,183           | @benchmark[problem-0029:count_distinct_powers_100]  |
| $10^3$  | 977,358         | @benchmark[problem-0029:count_distinct_powers_1k]   |
| $10^4$  | 99,347,607      | @benchmark[problem-0029:count_distinct_powers_10k]  |
| $10^5$  | 9,981,236,306   | @benchmark[problem-0029:count_distinct_powers_100k] |
